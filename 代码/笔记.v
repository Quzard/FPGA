上面代码的输入(定义为input)为a,b和cin，注意a,b前面有一个[N-1:0]，这表示a与b的bit位宽为N，最高位为第N-1位，最低位为0位；而cin前面没有位宽设定，则表示1bit。
对于任意有意义的逻辑变量（wire/reg，输入输出端口等），必须指定其位宽，如果没有显式指定，位宽就默认为1bit

该段代码的输出(定义为output)为sum和cout，其中sum标准加法和，位宽为N bit，而cout则是1bit变量，表示加法进位位。

除了单方向的输入input和输出output外，电路还存在双向输入输出，所以Verilog采用inout命名这类端口。

parameter 类型用来定义模块全局符号常量，等效于C语言的参数设定。

assign 语句是指连续赋值的意思。加法器是一个组合电路，所以当输入变化时，输出一定立刻响应，而
且这个过程是持续不断的。

always 语句是表明所描述的电路行为将被重复执行，而执行机制是通过对一个称为敏感变量表的事件驱动来实现。
可综合的 always 语句只有两种写法，第一种为电平事件驱动，当敏感事件列表中的信号发生变化，就执行内部的语句块，
1、  always @ (a or b or c or d or sel)//abcd sel均为敏感信号列表   组合电路的描述方法
2、  always @ (posedge clock or posedge reset )//时序电路的描述方法

posedge 表示上升沿触发，而 negedge 表示下降沿触发

always #10 clock = ~clock;//产生20ns为周期的clock方波

每一个带时钟的 always 语句块都是并发执行的
但在 always 语句块内部，任何一个语句块（以 begin 开始，end 结束）都是串行执行的

reg 并不都是寄存器类型，也有可能为连线。
对于 reg 类型不能准确定义为寄存器，而是有可能为锁存器或者组合电路中的临时连线，
这对Verilog语言设计而言，可以认为是一个较大缺憾



for(i=0;i<255;i=i+1)
	j=j+1;
end

for 语句是并行完全展开语句，而不是串行多周期执行


$display("Error with sel signal");
$display语句,该语句与C语言中的打印语句非常类似,能够在仿真时输出各类中间变量

3'b001//3bit二进制011
4'd5//4bit十进制5
5'o27//5bit八进制27
6'h3f//6bit十六进制3f

[size]'base value
//size定义以bit位计的常量的位长;
base 为

o或O(表示八进制),
b或B(表示二进制),
d 或D(表示十进制),
h或H(表示十六进制)之一;

value是基于base的值的数字序列。
值x和z以及十六进制中的a到f不区分大小写。

基数格式的长度定义(size)是可选的。如果没有定义一个整数型的长度,
数的长度为相应值中定义的位数。如果定义的长度比为常量指定的长度长,
通常在左边填0补位。但是如果数最左边一位为x 或z ,
就相应地用x 或z 在左边补位。此外,如果长度定义得更小,那么最左边的位相应地被截断。
'

线网类型主要有wire和tri两种。线网类型用于对结构化器件之间的物理连线的建模。如器件的引脚,内部器件如与非门的输出等。
